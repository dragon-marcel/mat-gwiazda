<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.ai/db-plan.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.ai/db-plan.md" />
              <option name="originalContent" value="# Schemat bazy danych PostgreSQL — MatGwiazda (MVP)&#10;&#10;Poniższy dokument zawiera kompletny schemat bazy danych zaprojektowany dla aplikacji MatGwiazda (MVP). Zawiera definicje tabel, kolumn, typów danych, ograniczeń, indeksów, relacji oraz przykładowe reguły Row Level Security (RLS) zgodne z wymaganiami PRD i notatek sesji planowania.&#10;&#10;---&#10;&#10;## 1. Lista tabel z ich kolumnami, typami danych i ograniczeniami&#10;&#10;Uwaga: klucze główne są typu UUID (zalecane dla rozproszonego środowiska). Czasowe pola wykorzystują timestamptz.&#10;&#10;### 1.1. `users` — dane kont użytkowników i ich status&#10;Tabela users bedzie wykorzystywana w Supabase Auth do zarządzania uwierzytelnianiem.&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- email: varchar(255) NOT NULL UNIQUE&#10;- password: varchar(255) NOT NULL -- hash hasła (bcrypt/argon2)&#10;- user_name: varchar(100) -- NOT NULL&#10;- role: user_role NOT NULL DEFAULT 'student' -- enum (student, teacher, admin)&#10;- current_level: smallint NOT NULL DEFAULT 1 CHECK (current_level &gt;= 1 AND current_level &lt;= 8)&#10;- points: integer NOT NULL DEFAULT 0 CHECK (points &gt;= 0)&#10;- stars: integer NOT NULL DEFAULT 0 CHECK (stars &gt;= 0)&#10;- is_active: boolean NOT NULL DEFAULT true&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;- last_active_at: timestamptz&#10;- active_progress_id: uuid NULL -- reference to currently assigned progress (nullable)&#10;&#10;Notatki:&#10;- `points` i `stars` są przechowywane tutaj dla szybkiego odczytu profilu użytkownika.&#10;- `active_progress_id` wskazuje aktualną przypisaną użytkownikowi próbę (rekord `progress`). Dzięki temu frontend może po odświeżeniu strony pobrać i kontynuować tę próbę. Kolumna jest nullable i ustawiana na NULL po finalizacji progress.&#10;&#10;### 1.2. `tasks` — repozytorium zadań (treść zadania, opcje, poprawna odpowiedź, wyjaśnienie)&#10;&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- level: smallint NOT NULL CHECK (level &gt;= 1 AND level &lt;= 8)&#10;- prompt: text NOT NULL -- treść zadania (krótka), jeżeli zadania są generowane przez AI można tu przechowywać wzorce/stan&#10;- options: jsonb NOT NULL CHECK (jsonb_typeof(options) = 'array') -- tablica 4 elementów z tekstami odpow.; format: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]&#10;- correct_option_index: smallint NOT NULL CHECK (correct_option_index &gt;= 0) -- indeks poprawnej odpowiedzi w tablicy options (0..3)&#10;- explanation: text -- krótkie wyjaśnienie rozwiązania&#10;- created_by: uuid REFERENCES users(id) ON DELETE SET NULL -- identyfikator twórcy (system/AI/admin)&#10;- is_active: boolean NOT NULL DEFAULT true&#10;- metadata: jsonb -- dodatkowe dane (np. tags, source=ai, template_id)&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;&#10;Notatki:&#10;- `options` jako JSONB daje elastyczność (np. lokalizacje, dodatkowe atrybuty przy opcjach). Jeśli preferowane jest pełne normalizowanie, można zamiast tego wprowadzić tabelę `task_options` z FK do `tasks`.&#10;- Zakładamy 4 opcje na zadanie (zgodnie z PRD). Aplikacja powinna walidować długość tablicy `options` i zakres `correct_option_index`.&#10;- W modelu MVP każde wygenerowane zadanie jest instancją powiązaną z jednym rekordem `progress`. Przy generowaniu zadania backend tworzy zarówno `tasks` jak i odpowiadający `progress`, dzięki czemu historia prób od początku istnienia instancji jest zachowana.&#10;&#10;### 1.3. `progress` — historia prób/rozwiązań użytkowników (główna tabela analityczna)&#10;&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- user_id: uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE&#10;- task_id: uuid NOT NULL REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE  -- each task instance is unique per attempt&#10;- attempt_number integer NOT NULL DEFAULT 1&#10;- selected_option_index smallint,&#10;- is_correct boolean NOT NULL DEFAULT false,&#10;- points_awarded integer NOT NULL DEFAULT 0 CHECK (points_awarded &gt;= 0)&#10;- time_taken_ms integer -- czas w ms spędzony na zadaniu&#10;- finalized boolean NOT NULL DEFAULT false -- czy próba została zakończona/submitted&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;&#10;Notatki:&#10;- `progress` łączy `users` z `tasks`. W tym modelu każde wygenerowane `task` ma odpowiadający rekord `progress` utworzony w momencie generowania (status assigned).&#10;- Aby wymusić relację 1:1 (task -&gt; progress) dodajemy unikatowe ograniczenie na `progress.task_id`.&#10;- FK z `ON DELETE CASCADE` zgodnie z decyzją sesji planowania: usunięcie użytkownika usuwa powiązane rekordy historyczne; usunięcie instancji zadania usuwa powiązany wpis w `progress`.&#10;&#10;&#10;## 2. Relacje między tabelami (kardynalność)&#10;&#10;- users 1 --- * progress&#10;  - Jeden użytkownik może mieć wiele wpisów w `progress` (wiele prób / wygenerowanych zadań dla jednego użytkownika).&#10;- tasks 1 --- 1 progress&#10;  - Każde wygenerowane zadanie jest unikalną instancją powiązaną z dokładnie jednym wpisem `progress` (zadania są generowane per-attempt). Zgodnie z flow generowania, backend tworzy task + progress jednocześnie i przypisuje `progress.id` do `users.active_progress_id`.&#10;&#10;Kardynalność: relacja `users` &lt;-&gt; `tasks` nie jest modelowana jako tradycyjne wiele-do-wielu; zamiast tego `progress` przechowuje próby użytkownika, a każde `task` jest jednorazową instancją powiązaną 1:1 z `progress`.&#10;&#10;---&#10;&#10;## 3. Indeksy (zalecane)&#10;&#10;- UNIQUE INDEX na `users(email)` (już wymieniony jako UNIQUE constraint).&#10;&#10;- Indexy na `progress`:&#10;  - CREATE INDEX idx_progress_user_id ON progress (user_id);&#10;  - CREATE UNIQUE INDEX idx_progress_task_id_unique ON progress (task_id); -- gwarantuje relację 1:1 tasks-&gt;progress&#10;  - CREATE INDEX idx_progress_user_created_at ON progress (user_id, created_at DESC);&#10;  - CREATE INDEX idx_progress_user_is_correct ON progress (user_id, is_correct);&#10;&#10;- Indexy na `tasks`:&#10;  - CREATE INDEX idx_tasks_level_active ON tasks (level, is_active);&#10;  - CREATE INDEX idx_tasks_created_by ON tasks (created_by);&#10;  - CREATE INDEX idx_tasks_metadata_gin ON tasks USING GIN (metadata);&#10;&#10;- Indexy na `users`:&#10;  - CREATE INDEX idx_users_current_level ON users (current_level);&#10;  - CREATE INDEX idx_users_last_active_at ON users (last_active_at DESC);&#10;  - CREATE INDEX idx_users_active_progress_id ON users (active_progress_id);&#10;&#10;Wskazówki:&#10;- Indeksy kompozytowe (np. user_id + created_at) przyspieszają odczyt historii użytkownika i budowanie dashboardów.&#10;- GIN dla pól jsonb tylko gdy rzeczywiście wyszukujemy po polach JSON.&#10;&#10;---&#10;&#10;## 4. Zasady PostgreSQL (Row Level Security - RLS) i polityki dostępu&#10;&#10;Założenia bezpieczeństwa:&#10;- Użytkownik powinien móc czytać i modyfikować własne wpisy w `progress` oraz odczytywać swój wiersz w `users`.&#10;- Role administracyjne (np. `admin`) mają dostęp do pełnych danych.&#10;- Supabase oferuje własny system auth; poniższe polityki zakładają standardowe role Postgres (`app_user` jako rola aplikacji) lub role Supabase i mechanizm JWT.&#10;&#10;Przykładowe polecenia SQL do włączenia RLS i utworzenia polityk (do zaadaptowania w migracjach):&#10;&#10;-- Włączenie RLS dla tabeli progress&#10;ALTER TABLE progress ENABLE ROW LEVEL SECURITY;&#10;&#10;-- Polityka: użytkownicy mogą wstawiać swoje własne wpisy (aplikacja będzie zapewniać user_id z jwt)&#10;CREATE POLICY progress_insert_own ON progress FOR INSERT USING (true) WITH CHECK (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: użytkownicy mogą czytać tylko swoje wiersze&#10;CREATE POLICY progress_select_own ON progress FOR SELECT USING (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: użytkownicy mogą aktualizować tylko swoje wiersze&#10;CREATE POLICY progress_update_own ON progress FOR UPDATE USING (user_id = current_setting('app.current_user_id')::uuid) WITH CHECK (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: admin (rola) może mieć pełny dostęp (przykład)&#10;CREATE POLICY progress_admin ON progress FOR ALL TO role_admin USING (true);&#10;&#10;-- Podobne polityki dla users: użytkownicy mogą SELECT/UPDATE swój własny wiersz&#10;ALTER TABLE users ENABLE ROW LEVEL SECURITY;&#10;CREATE POLICY users_select_own ON users FOR SELECT USING (id = current_setting('app.current_user_id')::uuid);&#10;CREATE POLICY users_update_own ON users FOR UPDATE USING (id = current_setting('app.current_user_id')::uuid) WITH CHECK (id = current_setting('app.current_user_id')::uuid);&#10;&#10;Uwagi dotyczące `current_setting('app.current_user_id')`:&#10;- W migracjach i konfiguracji serwera aplikacja (Spring Boot) przed zapytaniem ustawia wartość kontekstu: `SET LOCAL app.current_user_id = '&lt;user-uuid&gt;';` lub używa mechanizmu Supabase JWT claims mapowania (np. `auth.uid()` w Supabase).&#10;- Alternatywnie, gdy używasz Supabase, możesz dopasować polityki do `auth.uid()` oraz ról Supabase.&#10;&#10;---&#10;&#10;## 5. Ograniczenia, checki i integralność danych&#10;&#10;- `users.email` UNIQUE NOT NULL.&#10;- `users.current_level` CHECK (1..8).&#10;- `tasks.options` musi być tablicą JSON o długości 4 — wymuszane na poziomie aplikacji lub przez trigger.&#10;- `tasks.correct_option_index` musi wskazywać istniejący indeks w `options` — walidacja aplikacyjna lub trigger/constraint.&#10;- `progress.points_awarded` nieujemne.&#10;- Wszystkie FK mają `ON DELETE/UPDATE CASCADE` tam gdzie zadecydowano w sesji (szczególnie w `progress`). W `tasks.created_by` zastosowano `ON DELETE SET NULL` by zachować historię zadań przy usunięciu użytkownika-tworcy.&#10;&#10;Przykładowy check na długość tablicy options (możliwy do dodania jako check wykorzystujący jsonb_array_length):&#10;- CHECK (jsonb_typeof(options) = 'array' AND jsonb_array_length(options) = 4)&#10;&#10;---&#10;&#10;## 6. Przykładowe polecenia CREATE TABLE (skrócone, gotowe do adaptacji jako migracje)&#10;&#10;-- Typ enum dla roli użytkownika&#10;CREATE TYPE user_role AS ENUM ('student', 'teacher', 'admin');&#10;&#10;-- users&#10;CREATE TABLE users (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  email varchar(255) NOT NULL UNIQUE,&#10;  password varchar(255) NOT NULL,&#10;  user_name varchar(100) NOT NULL,&#10;  role user_role NOT NULL DEFAULT 'student',&#10;  current_level smallint NOT NULL DEFAULT 1 CHECK (current_level &gt;= 1 AND current_level &lt;= 8),&#10;  points integer NOT NULL DEFAULT 0 CHECK (points &gt;= 0),&#10;  stars integer NOT NULL DEFAULT 0 CHECK (stars &gt;= 0),&#10;  is_active boolean NOT NULL DEFAULT true,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now(),&#10;  last_active_at timestamptz,&#10;  active_progress_id uuid NULL&#10;);&#10;&#10;-- tasks&#10;CREATE TABLE tasks (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  level smallint NOT NULL CHECK (level &gt;= 1 AND level &lt;= 8),&#10;  prompt text NOT NULL,&#10;  options jsonb NOT NULL CHECK (jsonb_typeof(options) = 'array' AND jsonb_array_length(options) = 4),&#10;  correct_option_index smallint NOT NULL CHECK (correct_option_index &gt;= 0 AND correct_option_index &lt; 4),&#10;  explanation text,&#10;  created_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  is_active boolean NOT NULL DEFAULT true,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now()&#10;);&#10;-- progress&#10;CREATE TABLE progress (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,&#10;  task_id uuid NOT NULL REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE,&#10;  attempt_number integer NOT NULL DEFAULT 1,&#10;  selected_option_index smallint,&#10;  is_correct boolean NOT NULL DEFAULT false,&#10;  points_awarded integer NOT NULL DEFAULT 0 CHECK (points_awarded &gt;= 0),&#10;  time_taken_ms integer,&#10;  finalized boolean NOT NULL DEFAULT false,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now()&#10;);&#10;&#10;-- Unikalne ograniczenie: każdemu taskowi odpowiada jeden progress (1:1)&#10;ALTER TABLE progress ADD CONSTRAINT uq_progress_task UNIQUE (task_id);&#10;&#10;-- Indexy pomocnicze&#10;CREATE INDEX idx_progress_user_id ON progress (user_id);&#10;CREATE INDEX idx_tasks_level_active ON tasks (level, is_active);&#10;CREATE INDEX idx_users_active_progress_id ON users (active_progress_id);&#10;&#10;## 6a. `learning_levels` — opis kompetencji / zakresu dla poziomów 1..8&#10;&#10;Aby w przejrzysty sposób przechowywać opis zakresu materiału i reguły generowania zadań dla poszczególnych poziomów, dodajemy tabelę `learning_levels`. Pozwala to na łatwe rozszerzanie i edytowanie opisów poziomów z audytem kto i kiedy wprowadził zmianę.&#10;&#10;CREATE TABLE (opis):&#10;- level: smallint PRIMARY KEY CHECK (level &gt;= 1 AND level &lt;= 8) -- numer poziomu&#10;- title: varchar(128) NOT NULL -- krótka nazwa poziomu (opcjonalnie)&#10;- description: text NOT NULL -- szczegółowy opis zakresu (użyj poniższych tekstów)&#10;- created_by: uuid REFERENCES users(id) ON DELETE SET NULL -- kto utworzył wpis&#10;- created_at: timestamptz NOT NULL DEFAULT now() -- kiedy utworzono&#10;- modified_by: uuid REFERENCES users(id) ON DELETE SET NULL -- kto ostatnio modyfikował&#10;- modified_at: timestamptz -- kiedy ostatnio zmodyfikowano&#10;&#10;Przykładowa definicja SQL do migracji:&#10;&#10;-- learning_levels&#10;CREATE TABLE learning_levels (&#10;  level smallint PRIMARY KEY CHECK (level &gt;= 1),&#10;  title varchar(128) NOT NULL,&#10;  description text NOT NULL,&#10;  created_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  modified_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  modified_at timestamptz&#10;);&#10;&#10;-- Opcjonalnie: powiązać `tasks.level` jako FK do `learning_levels(level)` zamiast surowego CHECK na zakres&#10;-- ALTER TABLE tasks ADD CONSTRAINT fk_tasks_level_learning_levels FOREIGN KEY (level) REFERENCES learning_levels(level);&#10;&#10;-- Seed / przykładowe wpisy dla poziomów 1..8 (użyj w migracji lub skrypcie seedującym):&#10;INSERT INTO learning_levels (level, title, description) VALUES&#10;  (1, 'Poziom 1', 'Dodawanie i odejmowanie w zakresie 100, porównywanie liczb, proste zadania tekstowe.'),&#10;  (2, 'Poziom 2', 'Mnożenie i dzielenie w zakresie 100, proste ułamki.'),&#10;  (3, 'Poziom 3', 'Działania do 1000, tabliczka mnożenia, dzielenie z resztą, ułamki zwykłe, jednostki miary (długość, masa, czas).'),&#10;  (4, 'Poziom 4', 'Liczby wielocyfrowe, ułamki i ich porównywanie.'),&#10;  (5, 'Poziom 5', 'Ułamki dziesiętne, procenty, wyrażenia algebraiczne.'),&#10;  (6, 'Poziom 6', 'Działania na ułamkach, proporcje, średnia arytmetyczna.'),&#10;  (7, 'Poziom 7', 'Potęgi i pierwiastki, równania i nierówności, obliczenia procentowe.'),&#10;  (8, 'Poziom 8', 'Funkcje liniowe, układy równań, twierdzenie Pitagorasa, statystyka i prawdopodobieństwo.');&#10;&#10;Notatki do implementacji:&#10;- `description` powinno być tekstem sformatowanym (markdown / HTML) jeśli planujesz je wyświetlać w panelu administracyjnym.&#10;- `created_by`/`modified_by` zakładają istnienie konta użytkownika (np. admin) — migracja seedująca może ustawić `created_by` NULL lub wskazać konto systemowe.&#10;- Jeżeli chcesz później umożliwić wersjonowanie opisów poziomów, można dodać tabelę `learning_levels_history` z pełnym śladem zmian.&#10;&#10;---&#10;&#10;(Umieszczono powyżej jako uzupełnienie do sekcji CREATE TABLE i mapy konceptualnej; zadbaj o dodanie migracji SQL do repozytorium migracji, np. Flyway/Liquibase, aby zapewnić spójność środowisk.)&#10;&#10;## 7. Dodatkowe uwagi i decyzje projektowe&#10;&#10;1. Stosowanie JSONB w `tasks.options` i `tasks.metadata` daje elastyczność dla generowanych przez AI treści (np. warianty tłumaczeń, formaty renderowania). Jeśli wymagana będzie silna normalizacja raportów (np. agregowanie po treści opcji), można wprowadzić tabelę `task_options` z FK do `tasks`.&#10;&#10;2. `progress` jest miejscem prawdy (single source of truth) dla analityki i historii. Dzięki indeksom i właściwemu modelowi można efektywnie obliczać:&#10;   - liczbę ukończonych zadań,&#10;   - zdobyte punkty w czasie,&#10;   - tempo rozwiązywania zadań,&#10;   - procent poprawnych odpowiedzi.&#10;&#10;3. Aktualizacja `users.points` i `users.stars`:&#10;   - Operacje aktualizacji punktów i finalizacji progress powinny działać w transakcjach: submit progress (ustawienie finalized=true i points_awarded) oraz aktualizacja users (points/stars/current_level oraz ustawienie users.active_progress_id = NULL) powinny być wykonane atomowo.&#10;&#10;4. Polityki RLS muszą być zsynchronizowane z mechanizmem uwierzytelniania (Supabase lub JWT używany przez Spring Boot). W Supabase rekomenduje się użycie `auth.uid()` w politykach zamiast `current_setting`.&#10;&#10;5. Backup i retencja: zaprojektuj politykę usuwania danych (np. anonimizacja / soft delete) zgodnie z wymaganiami prawnymi (RODO) i PRD. W tym szkicu nie wprowadzono pola `deleted_at` — można dodać `is_active`/`deleted_at` do każdej tabeli biznesowej.&#10;&#10;6. Monitorowanie i metryki: rozważ tworzenie widoków agregujących (materialized views) dla dashboardów (np. dzienne sumy punktów, nowe gwiazdki), które będą odświeżane periodycznie.&#10;&#10;---&#10;&#10;## 8. Mapa zgodności z wymaganiami PRD / sesji planowania&#10;&#10;- Rejestracja i logowanie: `users` (email, password) — DONE&#10;- Generowanie zadań przez AI: `tasks` (prompt, options, correct_option_index, explanation, metadata) — DONE (z opcją oznaczenia źródła AI w `metadata`)&#10;- System punktów i gwiazdek: `progress` zapisuje points_awarded; `users.points` i `users.stars` przechowują bieżący stan — DONE&#10;- Śledzenie ukończonych zadań i czasu: `progress.time_taken_ms`, `created_at` — DONE&#10;- RLS: przykładowe polityki i wskazówki (Supabase/Spring Boot) — DONE&#10;&#10;---&#10;&#10;Zaktualizowano: flow generowania zadań tworzy teraz `task` + `progress` i przypisuje `progress.id` do `users.active_progress_id`." />
              <option name="updatedContent" value="# Schemat bazy danych PostgreSQL — MatGwiazda (MVP)&#10;&#10;Poniższy dokument zawiera kompletny schemat bazy danych zaprojektowany dla aplikacji MatGwiazda (MVP). Zawiera definicje tabel, kolumn, typów danych, ograniczeń, indeksów, relacji oraz przykładowe reguły Row Level Security (RLS) zgodne z wymaganiami PRD i notatek sesji planowania.&#10;&#10;---&#10;&#10;## 1. Lista tabel z ich kolumnami, typami danych i ograniczeniami&#10;&#10;Uwaga: klucze główne są typu UUID (zalecane dla rozproszonego środowiska). Czasowe pola wykorzystują timestamptz.&#10;&#10;### 1.1. `users` — dane kont użytkowników i ich status&#10;Tabela users bedzie wykorzystywana w Supabase Auth do zarządzania uwierzytelnianiem.&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- email: varchar(255) NOT NULL UNIQUE&#10;- password: varchar(255) NOT NULL -- hash hasła (bcrypt/argon2)&#10;- user_name: varchar(100) -- NOT NULL&#10;- role: user_role NOT NULL DEFAULT 'student' -- enum (student, teacher, admin)&#10;- current_level: smallint NOT NULL DEFAULT 1 CHECK (current_level &gt;= 1 AND current_level &lt;= 8)&#10;- points: integer NOT NULL DEFAULT 0 CHECK (points &gt;= 0)&#10;- stars: integer NOT NULL DEFAULT 0 CHECK (stars &gt;= 0)&#10;- is_active: boolean NOT NULL DEFAULT true&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;- last_active_at: timestamptz&#10;- active_progress_id: uuid NULL -- reference to currently assigned progress (nullable)&#10;&#10;Notatki:&#10;- `points` i `stars` są przechowywane tutaj dla szybkiego odczytu profilu użytkownika.&#10;- `active_progress_id` wskazuje aktualną przypisaną użytkownikowi próbę (rekord `progress`). Dzięki temu frontend może po odświeżeniu strony pobrać i kontynuować tę próbę. Kolumna jest nullable i ustawiana na NULL po finalizacji progress.&#10;&#10;### 1.2. `tasks` — repozytorium zadań (treść zadania, opcje, poprawna odpowiedź, wyjaśnienie)&#10;&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- level: smallint NOT NULL CHECK (level &gt;= 1 AND level &lt;= 8)&#10;- prompt: text NOT NULL -- treść zadania (krótka), jeżeli zadania są generowane przez AI można tu przechowywać wzorce/stan&#10;- options: jsonb NOT NULL CHECK (jsonb_typeof(options) = 'array') -- tablica 4 elementów z tekstami odpow.; format: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]&#10;- correct_option_index: smallint NOT NULL CHECK (correct_option_index &gt;= 0) -- indeks poprawnej odpowiedzi w tablicy options (0..3)&#10;- explanation: text -- krótkie wyjaśnienie rozwiązania&#10;- created_by: uuid REFERENCES users(id) ON DELETE SET NULL -- identyfikator twórcy (system/AI/admin)&#10;- is_active: boolean NOT NULL DEFAULT true&#10;- metadata: jsonb -- dodatkowe dane (np. tags, source=ai, template_id)&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;&#10;Notatki:&#10;- `options` jako JSONB daje elastyczność (np. lokalizacje, dodatkowe atrybuty przy opcjach). Jeśli preferowane jest pełne normalizowanie, można zamiast tego wprowadzić tabelę `task_options` z FK do `tasks`.&#10;- Zakładamy 4 opcje na zadanie (zgodnie z PRD). Aplikacja powinna walidować długość tablicy `options` i zakres `correct_option_index`.&#10;- W modelu MVP każde wygenerowane zadanie jest instancją powiązaną z jednym rekordem `progress`. Przy generowaniu zadania backend tworzy zarówno `tasks` jak i odpowiadający `progress`, dzięki czemu historia prób od początku istnienia instancji jest zachowana.&#10;&#10;### 1.3. `progress` — historia prób/rozwiązań użytkowników (główna tabela analityczna)&#10;&#10;CREATE TABLE (opis):&#10;- id: uuid PRIMARY KEY DEFAULT gen_random_uuid()&#10;- user_id: uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE&#10;- task_id: uuid NOT NULL REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE  -- each task instance is unique per attempt&#10;- attempt_number integer NOT NULL DEFAULT 1&#10;- selected_option_index smallint,&#10;- is_correct boolean NOT NULL DEFAULT false,&#10;- points_awarded integer NOT NULL DEFAULT 0 CHECK (points_awarded &gt;= 0)&#10;- time_taken_ms integer -- czas w ms spędzony na zadaniu&#10;- finalized boolean NOT NULL DEFAULT false -- czy próba została zakończona/submitted&#10;- created_at: timestamptz NOT NULL DEFAULT now()&#10;- updated_at: timestamptz NOT NULL DEFAULT now()&#10;&#10;Notatki:&#10;- `progress` łączy `users` z `tasks`. W tym modelu każde wygenerowane `task` ma odpowiadający rekord `progress` utworzony w momencie generowania (status assigned).&#10;- Aby wymusić relację 1:1 (task -&gt; progress) dodajemy unikatowe ograniczenie na `progress.task_id`.&#10;- FK z `ON DELETE CASCADE` zgodnie z decyzją sesji planowania: usunięcie użytkownika usuwa powiązane rekordy historyczne; usunięcie instancji zadania usuwa powiązany wpis w `progress`.&#10;&#10;&#10;## 2. Relacje między tabelami (kardynalność)&#10;&#10;- users 1 --- * progress&#10;  - Jeden użytkownik może mieć wiele wpisów w `progress` (wiele prób / wygenerowanych zadań dla jednego użytkownika).&#10;- tasks 1 --- 1 progress&#10;  - Każde wygenerowane zadanie jest unikalną instancją powiązaną z dokładnie jednym wpisem `progress` (zadania są generowane per-attempt). Zgodnie z flow generowania, backend tworzy task + progress jednocześnie i przypisuje `progress.id` do `users.active_progress_id`.&#10;&#10;Kardynalność: relacja `users` &lt;-&gt; `tasks` nie jest modelowana jako tradycyjne wiele-do-wielu; zamiast tego `progress` przechowuje próby użytkownika, a każde `task` jest jednorazową instancją powiązaną 1:1 z `progress`.&#10;&#10;---&#10;&#10;## 3. Indeksy (zalecane)&#10;&#10;- UNIQUE INDEX na `users(email)` (już wymieniony jako UNIQUE constraint).&#10;&#10;- Indexy na `progress`:&#10;  - CREATE INDEX idx_progress_user_id ON progress (user_id);&#10;  - CREATE UNIQUE INDEX idx_progress_task_id_unique ON progress (task_id); -- gwarantuje relację 1:1 tasks-&gt;progress&#10;  - CREATE INDEX idx_progress_user_created_at ON progress (user_id, created_at DESC);&#10;  - CREATE INDEX idx_progress_user_is_correct ON progress (user_id, is_correct);&#10;&#10;- Indexy na `tasks`:&#10;  - CREATE INDEX idx_tasks_level_active ON tasks (level, is_active);&#10;  - CREATE INDEX idx_tasks_created_by ON tasks (created_by);&#10;  - CREATE INDEX idx_tasks_metadata_gin ON tasks USING GIN (metadata);&#10;&#10;- Indexy na `users`:&#10;  - CREATE INDEX idx_users_current_level ON users (current_level);&#10;  - CREATE INDEX idx_users_last_active_at ON users (last_active_at DESC);&#10;  - CREATE INDEX idx_users_active_progress_id ON users (active_progress_id);&#10;&#10;Wskazówki:&#10;- Indeksy kompozytowe (np. user_id + created_at) przyspieszają odczyt historii użytkownika i budowanie dashboardów.&#10;- GIN dla pól jsonb tylko gdy rzeczywiście wyszukujemy po polach JSON.&#10;&#10;---&#10;&#10;## 4. Zasady PostgreSQL (Row Level Security - RLS) i polityki dostępu&#10;&#10;Założenia bezpieczeństwa:&#10;- Użytkownik powinien móc czytać i modyfikować własne wpisy w `progress` oraz odczytywać swój wiersz w `users`.&#10;- Role administracyjne (np. `admin`) mają dostęp do pełnych danych.&#10;- Supabase oferuje własny system auth; poniższe polityki zakładają standardowe role Postgres (`app_user` jako rola aplikacji) lub role Supabase i mechanizm JWT.&#10;&#10;Przykładowe polecenia SQL do włączenia RLS i utworzenia polityk (do zaadaptowania w migracjach):&#10;&#10;-- Włączenie RLS dla tabeli progress&#10;ALTER TABLE progress ENABLE ROW LEVEL SECURITY;&#10;&#10;-- Polityka: użytkownicy mogą wstawiać swoje własne wpisy (aplikacja będzie zapewniać user_id z jwt)&#10;CREATE POLICY progress_insert_own ON progress FOR INSERT USING (true) WITH CHECK (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: użytkownicy mogą czytać tylko swoje wiersze&#10;CREATE POLICY progress_select_own ON progress FOR SELECT USING (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: użytkownicy mogą aktualizować tylko swoje wiersze&#10;CREATE POLICY progress_update_own ON progress FOR UPDATE USING (user_id = current_setting('app.current_user_id')::uuid) WITH CHECK (user_id = current_setting('app.current_user_id')::uuid);&#10;&#10;-- Polityka: admin (rola) może mieć pełny dostęp (przykład)&#10;CREATE POLICY progress_admin ON progress FOR ALL TO role_admin USING (true);&#10;&#10;-- Podobne polityki dla users: użytkownicy mogą SELECT/UPDATE swój własny wiersz&#10;ALTER TABLE users ENABLE ROW LEVEL SECURITY;&#10;CREATE POLICY users_select_own ON users FOR SELECT USING (id = current_setting('app.current_user_id')::uuid);&#10;CREATE POLICY users_update_own ON users FOR UPDATE USING (id = current_setting('app.current_user_id')::uuid) WITH CHECK (id = current_setting('app.current_user_id')::uuid);&#10;&#10;Uwagi dotyczące `current_setting('app.current_user_id')`:&#10;- W migracjach i konfiguracji serwera aplikacja (Spring Boot) przed zapytaniem ustawia wartość kontekstu: `SET LOCAL app.current_user_id = '&lt;user-uuid&gt;';` lub używa mechanizmu Supabase JWT claims mapowania (np. `auth.uid()` w Supabase).&#10;- Alternatywnie, gdy używasz Supabase, możesz dopasować polityki do `auth.uid()` oraz ról Supabase.&#10;&#10;---&#10;&#10;## 5. Ograniczenia, checki i integralność danych&#10;&#10;- `users.email` UNIQUE NOT NULL.&#10;- `users.current_level` CHECK (1..8).&#10;- `tasks.options` musi być tablicą JSON o długości 4 — wymuszane na poziomie aplikacji lub przez trigger.&#10;- `tasks.correct_option_index` musi wskazywać istniejący indeks w `options` — walidacja aplikacyjna lub trigger/constraint.&#10;- `progress.points_awarded` nieujemne.&#10;- Wszystkie FK mają `ON DELETE/UPDATE CASCADE` tam gdzie zadecydowano w sesji (szczególnie w `progress`). W `tasks.created_by` zastosowano `ON DELETE SET NULL` by zachować historię zadań przy usunięciu użytkownika-tworcy.&#10;&#10;Przykładowy check na długość tablicy options (możliwy do dodania jako check wykorzystujący jsonb_array_length):&#10;- CHECK (jsonb_typeof(options) = 'array' AND jsonb_array_length(options) = 4)&#10;&#10;---&#10;&#10;## 6. Przykładowe polecenia CREATE TABLE (skrócone, gotowe do adaptacji jako migracje)&#10;&#10;-- Typ enum dla roli użytkownika&#10;CREATE TYPE user_role AS ENUM ('student', 'teacher', 'admin');&#10;&#10;-- users&#10;CREATE TABLE users (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  email varchar(255) NOT NULL UNIQUE,&#10;  password varchar(255) NOT NULL,&#10;  user_name varchar(100) NOT NULL,&#10;  role user_role NOT NULL DEFAULT 'student',&#10;  current_level smallint NOT NULL DEFAULT 1 CHECK (current_level &gt;= 1 AND current_level &lt;= 8),&#10;  points integer NOT NULL DEFAULT 0 CHECK (points &gt;= 0),&#10;  stars integer NOT NULL DEFAULT 0 CHECK (stars &gt;= 0),&#10;  is_active boolean NOT NULL DEFAULT true,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now(),&#10;  last_active_at timestamptz,&#10;  active_progress_id uuid NULL&#10;);&#10;&#10;-- tasks&#10;CREATE TABLE tasks (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  level smallint NOT NULL CHECK (level &gt;= 1 AND level &lt;= 8),&#10;  prompt text NOT NULL,&#10;  options jsonb NOT NULL CHECK (jsonb_typeof(options) = 'array' AND jsonb_array_length(options) = 4),&#10;  correct_option_index smallint NOT NULL CHECK (correct_option_index &gt;= 0 AND correct_option_index &lt; 4),&#10;  explanation text,&#10;  created_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  is_active boolean NOT NULL DEFAULT true,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now()&#10;);&#10;-- progress&#10;CREATE TABLE progress (&#10;  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),&#10;  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,&#10;  task_id uuid NOT NULL REFERENCES tasks(id) ON DELETE CASCADE ON UPDATE CASCADE,&#10;  attempt_number integer NOT NULL DEFAULT 1,&#10;  selected_option_index smallint,&#10;  is_correct boolean NOT NULL DEFAULT false,&#10;  points_awarded integer NOT NULL DEFAULT 0 CHECK (points_awarded &gt;= 0),&#10;  time_taken_ms integer,&#10;  finalized boolean NOT NULL DEFAULT false,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  updated_at timestamptz NOT NULL DEFAULT now()&#10;);&#10;&#10;-- Unikalne ograniczenie: każdemu taskowi odpowiada jeden progress (1:1)&#10;ALTER TABLE progress ADD CONSTRAINT uq_progress_task UNIQUE (task_id);&#10;&#10;-- Indexy pomocnicze&#10;CREATE INDEX idx_progress_user_id ON progress (user_id);&#10;CREATE INDEX idx_tasks_level_active ON tasks (level, is_active);&#10;CREATE INDEX idx_users_active_progress_id ON users (active_progress_id);&#10;&#10;## 6a. `learning_levels` — opis kompetencji / zakresu dla poziomów 1..8&#10;&#10;Aby w przejrzysty sposób przechowywać opis zakresu materiału i reguły generowania zadań dla poszczególnych poziomów, dodajemy tabelę `learning_levels`. Pozwala to na łatwe rozszerzanie i edytowanie opisów poziomów z audytem kto i kiedy wprowadził zmianę.&#10;&#10;CREATE TABLE (opis):&#10;- level: smallint PRIMARY KEY CHECK (level &gt;= 1 AND level &lt;= 8) -- numer poziomu&#10;- title: varchar(128) NOT NULL -- krótka nazwa poziomu (opcjonalnie)&#10;- description: text NOT NULL -- szczegółowy opis zakresu (użyj poniższych tekstów)&#10;- created_by: uuid REFERENCES users(id) ON DELETE SET NULL -- kto utworzył wpis&#10;- created_at: timestamptz NOT NULL DEFAULT now() -- kiedy utworzono&#10;- modified_by: uuid REFERENCES users(id) ON DELETE SET NULL -- kto ostatnio modyfikował&#10;- modified_at: timestamptz -- kiedy ostatnio zmodyfikowano&#10;&#10;Przykładowa definicja SQL do migracji:&#10;&#10;-- learning_levels&#10;CREATE TABLE learning_levels (&#10;  level smallint PRIMARY KEY CHECK (level &gt;= 1),&#10;  title varchar(128) NOT NULL,&#10;  description text NOT NULL,&#10;  created_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  created_at timestamptz NOT NULL DEFAULT now(),&#10;  modified_by uuid REFERENCES users(id) ON DELETE SET NULL,&#10;  modified_at timestamptz&#10;);&#10;&#10;-- Opcjonalnie: powiązać `tasks.level` jako FK do `learning_levels(level)` zamiast surowego CHECK na zakres&#10;-- ALTER TABLE tasks ADD CONSTRAINT fk_tasks_level_learning_levels FOREIGN KEY (level) REFERENCES learning_levels(level);&#10;&#10;-- Seed / przykładowe wpisy dla poziomów 1..8 (użyj w migracji lub skrypcie seedującym):&#10;INSERT INTO learning_levels (level, title, description) VALUES&#10;  (1, 'Poziom 1', 'Dodawanie i odejmowanie w zakresie 100, porównywanie liczb, proste zadania tekstowe.'),&#10;  (2, 'Poziom 2', 'Mnożenie i dzielenie w zakresie 100, proste ułamki.'),&#10;  (3, 'Poziom 3', 'Działania do 1000, tabliczka mnożenia, dzielenie z resztą, ułamki zwykłe, jednostki miary (długość, masa, czas).'),&#10;  (4, 'Poziom 4', 'Liczby wielocyfrowe, ułamki i ich porównywanie.'),&#10;  (5, 'Poziom 5', 'Ułamki dziesiętne, procenty, wyrażenia algebraiczne.'),&#10;  (6, 'Poziom 6', 'Działania na ułamkach, proporcje, średnia arytmetyczna.'),&#10;  (7, 'Poziom 7', 'Potęgi i pierwiastki, równania i nierówności, obliczenia procentowe.'),&#10;  (8, 'Poziom 8', 'Funkcje liniowe, układy równań, twierdzenie Pitagorasa, statystyka i prawdopodobieństwo.');&#10;&#10;Notatki do implementacji:&#10;- `description` powinno być tekstem sformatowanym (markdown / HTML) jeśli planujesz je wyświetlać w panelu administracyjnym.&#10;- `created_by`/`modified_by` zakładają istnienie konta użytkownika (np. admin) — migracja seedująca może ustawić `created_by` NULL lub wskazać konto systemowe.&#10;- Jeżeli chcesz później umożliwić wersjonowanie opisów poziomów, można dodać tabelę `learning_levels_history` z pełnym śladem zmian.&#10;&#10;---&#10;&#10;(Umieszczono powyżej jako uzupełnienie do sekcji CREATE TABLE i mapy konceptualnej; zadbaj o dodanie migracji SQL do repozytorium migracji, np. Flyway/Liquibase, aby zapewnić spójność środowisk.)&#10;&#10;## 7. Dodatkowe uwagi i decyzje projektowe&#10;&#10;1. Stosowanie JSONB w `tasks.options` i `tasks.metadata` daje elastyczność dla generowanych przez AI treści (np. warianty tłumaczeń, formaty renderowania). Jeśli wymagana będzie silna normalizacja raportów (np. agregowanie po treści opcji), można wprowadzić tabelę `task_options` z FK do `tasks`.&#10;&#10;2. `progress` jest miejscem prawdy (single source of truth) dla analityki i historii. Dzięki indeksom i właściwemu modelowi można efektywnie obliczać:&#10;   - liczbę ukończonych zadań,&#10;   - zdobyte punkty w czasie,&#10;   - tempo rozwiązywania zadań,&#10;   - procent poprawnych odpowiedzi.&#10;&#10;3. Aktualizacja `users.points` i `users.stars`:&#10;   - Operacje aktualizacji punktów i finalizacji progress powinny działać w transakcjach: submit progress (ustawienie finalized=true i points_awarded) oraz aktualizacja users (points/stars/current_level oraz ustawienie users.active_progress_id = NULL) powinny być wykonane atomowo.&#10;&#10;4. Polityki RLS muszą być zsynchronizowane z mechanizmem uwierzytelniania (Supabase lub JWT używany przez Spring Boot). W Supabase rekomenduje się użycie `auth.uid()` w politykach zamiast `current_setting`.&#10;&#10;5. Backup i retencja: zaprojektuj politykę usuwania danych (np. anonimizacja / soft delete) zgodnie z wymaganiami prawnymi (RODO) i PRD. W tym szkicu nie wprowadzono pola `deleted_at` — można dodać `is_active`/`deleted_at` do każdej tabeli biznesowej.&#10;&#10;6. Monitorowanie i metryki: rozważ tworzenie widoków agregujących (materialized views) dla dashboardów (np. dzienne sumy punktów, nowe gwiazdki), które będą odświeżane periodycznie.&#10;&#10;---&#10;&#10;## 8. Mapa zgodności z wymaganiami PRD / sesji planowania&#10;&#10;- Rejestracja i logowanie: `users` (email, password) — DONE&#10;- Generowanie zadań przez AI: `tasks` (prompt, options, correct_option_index, explanation, metadata) — DONE (z opcją oznaczenia źródła AI w `metadata`)&#10;- System punktów i gwiazdek: `progress` zapisuje points_awarded; `users.points` i `users.stars` przechowują bieżący stan — DONE&#10;- Śledzenie ukończonych zadań i czasu: `progress.time_taken_ms`, `created_at` — DONE&#10;- RLS: przykładowe polityki i wskazówki (Supabase/Spring Boot) — DONE&#10;&#10;---&#10;&#10;Zaktualizowano: flow generowania zadań tworzy teraz `task` + `progress` i przypisuje `progress.id` do `users.active_progress_id`." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.ai/progress-endpoints.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.ai/progress-endpoints.md" />
              <option name="updatedContent" value="# Progress Endpoints - Specyfikacja i szkielet&#10;&#10;Endpointy do zgłaszania postępów użytkownika (submit answer) oraz przeglądania historii postępów.&#10;&#10;## Endpoints&#10;&#10;POST /api/v1/progress/submit&#10;- Cel: zgłoszenie odpowiedzi użytkownika dla zadania&#10;- Body DTO: `ProgressSubmitCommand` { taskId, selectedOptionIndex, timeTakenMs }&#10;- Response: 200 OK -&gt; `ProgressSubmitResponseDto` { isCorrect, pointsAwarded, userPoints, starsAwarded, leveledUp }&#10;- Transakcja: aktualizacja rekordu progress i atomowa aktualizacja punktów użytkownika (SELECT FOR UPDATE lub opt-lock)&#10;&#10;GET /api/v1/progress&#10;- Cel: lista prób użytkownika (filtrowanie: isCorrect, date range)&#10;- Response: 200 OK -&gt; `PagedResponse&lt;ProgressDto&gt;`&#10;&#10;GET /api/v1/progress/{id}&#10;- Cel: odczyt pojedynczej próby (właściciel lub admin)&#10;- Response: 200 OK -&gt; `ProgressDto`&#10;&#10;## Proponowane DTO (nazwy)&#10;- ProgressSubmitCommand&#10;- ProgressSubmitResponseDto&#10;- ProgressDto&#10;&#10;## Szkielet kontrolera (przykład)&#10;&#10;```java&#10;package pl.matgwiazda.progress;&#10;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/progress&quot;)&#10;public class ProgressController {&#10;    @PostMapping(&quot;/submit&quot;)&#10;    public ResponseEntity&lt;?&gt; submit(@RequestBody /* @Valid */ Object progressSubmitCommand) {&#10;        // TODO: transactional progress submit -&gt; update user points&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping&#10;    public ResponseEntity&lt;?&gt; list(/* Pageable, filters */) {&#10;        // TODO: zwrócić paged progress list&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; get(@PathVariable Long id) {&#10;        // TODO: sprawdzić czy właściciel lub admin&#10;        return ResponseEntity.ok().build();&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;Notatki: Dodaj testy obciążeniowe / konkursowe (concurrency) dla `submit` aby upewnić się, że aktualizacja punktów użytkownika jest bezpieczna." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/supabase/migrations/20251020083300_create_progress.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/supabase/migrations/20251020083300_create_progress.sql" />
              <option name="originalContent" value="--&#10;-- migration: create progress table, indexes, triggers and rls policies&#10;-- filename: 20251020083300_create_progress.sql&#10;-- purpose: create progress table linking users and tasks, indexes, updated_at trigger and rls&#10;-- affected: table: progress; indexes; triggers; rls policies&#10;-- notes: - all sql lowercase&#10;--        - depends on users and tasks tables existing (foreign keys)&#10;--        - enforces unique(task_id) to keep 1:1 tasks-&gt;progress relationship&#10;--        - rls enabled with granular policies for anon and authenticated roles&#10;--        - destructive operations: none in this migration&#10;--&#10;&#10;create table if not exists progress (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id uuid not null references users(id) on delete cascade on update cascade,&#10;  task_id uuid not null references tasks(id) on delete cascade on update cascade,&#10;  attempt_number integer not null default 1,&#10;  selected_option_index smallint check (selected_option_index &gt;= 0 and selected_option_index &lt; 4),&#10;  is_correct boolean not null,&#10;  points_awarded integer not null default 0 check (points_awarded &gt;= 0),&#10;  time_taken_ms integer,&#10;  created_at timestamptz not null default now(),&#10;  updated_at timestamptz not null default now(),&#10;  constraint progress_task_unique unique (task_id)&#10;);&#10;&#10;-- attach trigger to update updated_at on update&#10;-- note: refresh_updated_at_column() is created in the users migration; ensure that migration is applied first&#10;drop trigger if exists trg_progress_updated_at on progress;&#10;create trigger trg_progress_updated_at&#10;before update on progress&#10;for each row&#10;execute procedure refresh_updated_at_column();&#10;&#10;-- indexes for progress&#10;create index if not exists idx_progress_user_id on progress (user_id);&#10;create unique index if not exists idx_progress_task_id_unique on progress (task_id);&#10;create index if not exists idx_progress_user_created_at on progress (user_id, created_at desc);&#10;create index if not exists idx_progress_user_is_correct on progress (user_id, is_correct);&#10;&#10;-- enable row level security&#10;alter table progress enable row level security;&#10;&#10;-- rls policies for progress&#10;-- insert: authenticated users can insert rows for themselves only&#10;create policy progress_insert_authenticated_own&#10;  on progress&#10;  for insert&#10;  to authenticated&#10;  with check (user_id::text = auth.uid());&#10;&#10;-- insert: anon denied&#10;create policy progress_insert_anon_deny&#10;  on progress&#10;  for insert&#10;  to anon&#10;  with check (false);&#10;&#10;-- select: authenticated can read only their own progress&#10;create policy progress_select_authenticated_own&#10;  on progress&#10;  for select&#10;  to authenticated&#10;  using (user_id::text = auth.uid());&#10;&#10;-- select: anon denied&#10;create policy progress_select_anon_deny&#10;  on progress&#10;  for select&#10;  to anon&#10;  using (false);&#10;&#10;-- update: authenticated can update only their own rows&#10;create policy progress_update_authenticated_own&#10;  on progress&#10;  for update&#10;  to authenticated&#10;  using (user_id::text = auth.uid())&#10;  with check (user_id::text = auth.uid());&#10;&#10;-- update: anon denied&#10;create policy progress_update_anon_deny&#10;  on progress&#10;  for update&#10;  to anon&#10;  using (false)&#10;  with check (false);&#10;&#10;-- delete: deny deletes for authenticated clients; allow admin role to delete&#10;create policy progress_delete_authenticated_deny&#10;  on progress&#10;  for delete&#10;  to authenticated&#10;  using (false);&#10;&#10;create policy progress_delete_admin&#10;  on progress&#10;  for delete&#10;  to authenticated&#10;  using (auth.role() = 'admin');&#10;&#10;-- migration notes:&#10;-- apply users migration, then tasks migration, then this migration to ensure foreign key targets exist.&#10;-- this file intentionally contains only progress-related sql; users/tasks sql live in separate migration files.&#10;" />
              <option name="updatedContent" value="/*&#10; migration: create progress table, indexes, triggers and rls policies&#10; filename: 20251020083300_create_progress.sql&#10; purpose: create progress table linking users and tasks, indexes, updated_at trigger and rls&#10; affected: table: progress; indexes; triggers; rls policies&#10; notes: - all sql lowercase&#10;        - depends on users and tasks tables existing (foreign keys)&#10;        - enforces unique(task_id) to keep 1:1 tasks-&gt;progress relationship&#10;        - rls enabled with granular policies for anon and authenticated roles&#10;        - destructive operations: none in this migration&#10;*/&#10;&#10;create table if not exists progress (&#10;  id uuid primary key default gen_random_uuid(),&#10;  user_id uuid not null references users(id) on delete cascade on update cascade,&#10;  task_id uuid not null references tasks(id) on delete cascade on update cascade,&#10;  attempt_number integer not null default 1,&#10;  selected_option_index smallint check (selected_option_index &gt;= 0 and selected_option_index &lt; 4),&#10;  is_correct boolean not null,&#10;  points_awarded integer not null default 0 check (points_awarded &gt;= 0),&#10;  time_taken_ms integer,&#10;  created_at timestamptz not null default now(),&#10;  updated_at timestamptz not null default now(),&#10;  constraint progress_task_unique unique (task_id)&#10;);&#10;&#10;-- attach trigger to update updated_at on update&#10;-- note: refresh_updated_at_column() is created in the users migration; ensure that migration is applied first&#10;drop trigger if exists trg_progress_updated_at on progress;&#10;create trigger trg_progress_updated_at&#10;before update on progress&#10;for each row&#10;execute procedure refresh_updated_at_column();&#10;&#10;-- indexes for progress&#10;create index if not exists idx_progress_user_id on progress (user_id);&#10;create unique index if not exists idx_progress_task_id_unique on progress (task_id);&#10;create index if not exists idx_progress_user_created_at on progress (user_id, created_at desc);&#10;create index if not exists idx_progress_user_is_correct on progress (user_id, is_correct);&#10;&#10;-- enable row level security&#10;alter table progress enable row level security;&#10;&#10;-- rls policies for progress&#10;-- insert: authenticated users can insert rows for themselves only&#10;create policy progress_insert_authenticated_own&#10;  on progress&#10;  for insert&#10;  to authenticated&#10;  with check (user_id::text = auth.uid());&#10;&#10;-- insert: anon denied&#10;create policy progress_insert_anon_deny&#10;  on progress&#10;  for insert&#10;  to anon&#10;  with check (false);&#10;&#10;-- select: authenticated can read only their own progress&#10;create policy progress_select_authenticated_own&#10;  on progress&#10;  for select&#10;  to authenticated&#10;  using (user_id::text = auth.uid());&#10;&#10;-- select: anon denied&#10;create policy progress_select_anon_deny&#10;  on progress&#10;  for select&#10;  to anon&#10;  using (false);&#10;&#10;-- update: authenticated can update only their own rows&#10;create policy progress_update_authenticated_own&#10;  on progress&#10;  for update&#10;  to authenticated&#10;  using (user_id::text = auth.uid())&#10;  with check (user_id::text = auth.uid());&#10;&#10;-- update: anon denied&#10;create policy progress_update_anon_deny&#10;  on progress&#10;  for update&#10;  to anon&#10;  using (false)&#10;  with check (false);&#10;&#10;-- delete: deny deletes for authenticated clients; allow admin role to delete&#10;create policy progress_delete_authenticated_deny&#10;  on progress&#10;  for delete&#10;  to authenticated&#10;  using (false);&#10;&#10;create policy progress_delete_admin&#10;  on progress&#10;  for delete&#10;  to authenticated&#10;  using (auth.role() = 'admin');&#10;&#10;-- migration notes:&#10;-- apply users migration, then tasks migration, then this migration to ensure foreign key targets exist.&#10;-- this file intentionally contains only progress-related sql; users/tasks sql live in separate migration files." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>